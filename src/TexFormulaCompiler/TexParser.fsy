%{
open TexAst
open System
open System.Diagnostics
open Microsoft.FSharp.Text.Lexing
open Microsoft.FSharp.Text.Parsing
open ErrorHandling

let mutable domainSpecificAnalyzer = Unchecked.defaultof<DomainSpecificContext -> obj>
let mutable errorLogger = Unchecked.defaultof<ErrorLogger>

let analyzeDomainSpecificLanguage token = domainSpecificAnalyzer token

let analyzeDomainSpecificSource token startPos = 
    try
      analyzeDomainSpecificLanguage token
    with
      | DomainSpecificParseException(fString, pos) -> failwithf "%s at pos: %u" fString (startPos)

let analyzeDomainSpecificSingleSource src pos = 
    analyzeDomainSpecificSource (SRefValueSrc(src)) pos |> SRefValue

let isSome = function
    | Some(_) -> true
    | None -> false

let analyzeDomainSpecificSources sources = 
    let rec analyzeDomainSpecificSourcesInternal sources state = 
        match sources with
          | [] -> state
          | (src, pos)::t -> analyzeDomainSpecificSourcesInternal t ((analyzeDomainSpecificSource (MRefValueSrc(src)) pos)::state)
        
    analyzeDomainSpecificSourcesInternal sources [] 
    |> List.rev 
    |> MRefValue

let report (parseState : IParseState) sym = 
    let lexbuf = parseState.ParserLocalStore.["LexBuffer"] :?> LexBuffer<char>
    let errorMsg = sprintf "Unexpected symbol: %s. %s symbol required" (new String(lexbuf.Lexeme)) sym
    let error = Error(errorMsg, {Line = lexbuf.StartPos.Line; Column = lexbuf.StartPos.Column})
    errorLogger.ReportError(error)

let report msg pos = 
    let error = Error(msg, pos)
	errorLogger.ReportError(error)

let checkForArguments token argsOpt parseState =
    match (token, argsOpt) with
        | (_, None) -> report parseState "SOME should have parameters"; [Int(1)]
        | (_, Some(args)) -> 
                             Debug.Assert((Seq.length args) <> 0)
                             match (token, Seq.length args) with
                                 | (SUM, _) | (PROD, _) -> args
                                 | (_, l) when l > 1 -> report parseState "SOME should have only one arg"; [args.Head]
                                 | (_, _) -> args

let checkForArgument token argsOpt parseState = checkForArguments token argsOpt parseState |> Seq.head

let (|UnmatchedLeft|UnmatchedRight|UnmatchedBoth|MatchedBoth|) (actualLp, actualRp, expectedLp, expectedRp) = 
    if actualLp <> expectedLp && actualRp <> expectedRp then UnmatchedBoth
    elif actualLp <> expectedLp then UnmatchedLeft
    elif actualRp <> expectedRp then UnmatchedRight
    else MatchedBoth

let checkBalancedParen actualLp actualRp expectedLp expectedRp parseState = 
    match (actualLp, actualRp, expectedLp, expectedRp) with
        | UnmatchedLeft   -> report parseState "Unmatched left"
        | UnmatchedRight  -> report parseState "Unmatched right"
        | UnmatchedBoth   -> report parseState "Unmatched both"
        | MatchedBoth     -> ()

%}

%token <int> INT
%token <float> FLOAT
%token <string> DIFF
%token <string> ID
%token <string*int> SREFVAL
%token <(string*int) list> MREFVAL
%token LPAREN RPAREN LCURLY RCURLY EXCL CARET EQ UNDERSCORE SLASH COMMA
%token PLUS SUB MUL DIV 
%token FRAC SQRT SUM PROD INTEGRAL TIMES INFTY TO LIM BMOD TEXT SIN COS
%token PI EULERNUM
%token EOF

%left errorRule
%left errorRule1
%left recoverRule
%left missingSymbol
%right intError
%left SLASH
%left RCURLY RPAREN COMMA 
%left argSetPriority
%right LCURLY LPAREN loose_closing_paren
%left INT EULERNUM PI
%left ID
%left PLUS SUB
%left DIV MUL BMOD TIMES funcPriority 
%right EXCL CARET
%left funcSyntaxError
%left uMinus
%left unexpectedEnumeration
%left expressionOverAll1
%left expressionOverAll

%start start
%type <TexAst.Expr> start


%%

start:
	| expression EOF { $1 }

expression:
    | binaryExpression      { $1 }
	| highPriorityFunction   { $1 }


constant:
	| PI       { Constant(Pi) }
	| EULERNUM { Constant(E) }

sum:
    | SLASH SUM arguments  {
                             let args = checkForArguments TokenInternal.SUM $3 parseState
                             Sum(List.rev args)
                           }
    | SUM arguments        {
                               report parseState "SUM operation should starts with SLASH"
                               let args = checkForArguments TokenInternal.SUM $2 parseState
                               Sum(List.rev args)
                           }
    | SUM {
            report parseState "SUM HAS NO args"
            Sum([Int(1)])
          }
    | SLASH SUM {
            report parseState "SUM HAS NO args"
            Sum([Int(1)])
          }

prod:
    | SLASH PROD arguments  { 
                              let args = checkForArguments TokenInternal.PROD $3 parseState
                              Prod(List.rev args) 
                            }
	| PROD arguments        {
                              report parseState "PROD operation should starts with SLASH"
                              let args = checkForArguments TokenInternal.PROD $2 parseState
                              Prod(List.rev args) 
                            }
    | PROD                  {
                              report parseState "PROD HAS NO args"
                              Sum([Int(1)])
                            }
    | SLASH PROD            {
                              report parseState "PROD HAS NO args"
                              Sum([Int(1)])
                            }

fact:
    highPriorityFunction EXCL  { Fact($1) }

power:
    | arguments intCaret arguments  { 
                                   let arg1 = checkForArgument TokenInternal.POW $1 parseState
                                   let arg2 = checkForArgument TokenInternal.POW $3 parseState
                                   Pow(arg1, arg2) 
                                 }
    //| arguments arguments        { 
    //                               let arg1 = checkForArgument TokenInternal.POW $1 parseState
    //                               let arg2 = checkForArgument TokenInternal.POW $2 parseState
    //                               report parseState "MISSING CARET!!111223232"
    //                               Pow(arg1, arg2) 
    //                             }

frac:
    | SLASH FRAC arguments arguments   { 
                                         let arg1 = checkForArgument TokenInternal.FRAC $3 parseState
                                         let arg2 = checkForArgument TokenInternal.FRAC $4 parseState
                                         Div(arg1, arg2) 
                                       }
	| SLASH FRAC arguments error       {
                                         let arg = checkForArgument TokenInternal.FRAC $3 parseState
                                         report parseState "FRAC Missing second arg!"
                                         Div(arg, Int(1))
                                       }
    | FRAC arguments                   {
                                         let arg = checkForArgument TokenInternal.FRAC $2 parseState
                                         report parseState "FRAC Missing second arg"
                                         Div(arg, Int(1))
                                       }
	| FRAC                             {
                                         report parseState "FRAC HAS NO args"
                                         Div(Int(1), Int(1))
                                       }
	| SLASH FRAC                       {
                                         report parseState "FRAC HAS NO args"
                                         Div(Int(1), Int(1))
                                       }

integralPrefix:
    | SLASH INTEGRAL {}
    | INTEGRAL { report parseState "INTEGRAL op should start with SLASH" }

integral:
    | integralPrefix intUnderscore arguments intCaret arguments arguments intDiff { 
                      let arg1 = checkForArgument TokenInternal.INTEGRAL $6 parseState
                      let arg2 = checkForArgument TokenInternal.INTEGRAL $3 parseState
                      let arg3 = checkForArgument TokenInternal.INTEGRAL $5 parseState
                      //report parseState "INTEGRAL MISSING caret"
                      Integral(arg1, $7, arg2, arg3) 
                    }

intDiff:
    | DIFF { $1 }
    |      { 
             report parseState "INTEGRAL DIFF missing"
             "x"
           }

intCaret:
    | CARET {}
    | error %prec intError { report parseState "INTEGER CARET missing"}
intUnderscore:
    | UNDERSCORE {}
    | error %prec intError { report parseState "INTEGER UNDERSCORE missing"}

//limit:
//    SLASH LIM UNDERSCORE lCurly ID TO expression rCurly lCurly expression rCurly  { Lim($10, $5, $7) }

refPattern:
    | refValue                           { $1 }
	| SLASH TEXT LCURLY refValue RCURLY  { $4 }

refValue:
    | SREFVAL      { analyzeDomainSpecificSingleSource (fst $1) (snd $1) |> DsAst }
	| MREFVAL      { analyzeDomainSpecificSources $1 |> DsAst }

highPriorityFunction:    
    | INT                        { Int($1) }
    | FLOAT                      { Float($1) }
    | SLASH INFTY                { Float(Double.PositiveInfinity) }
    | LPAREN expression RPAREN   { $2 }
	| trigonometry               { $1 }
	| sum                        { $1 }
	| prod                       { $1 }
	| fact                       { $1 }
	| integral                   { $1 }
	| constant                   { $1 }
    | power                      { $1 }
    | frac                       { $1 }
	//| limit                    { $1 }
	| refPattern                 { $1 }
	| ID                         { 
                                   let a = 1
                                   Var($1) 
                                 }
    //| funcSyntaxError          { $1 }
    | errorRule                  { $1 }

	
sinPrefix:
    | SLASH SIN {}
    | SIN       { report parseState "SIN OP should starts with SLASH symbol"}

cosPrefix:
    | SLASH COS {}
    | COS       { report parseState "COS OP should starts with SLASH symbol"}

trigonometry: 
	| sinPrefix arguments                  { 
                                             let arg = checkForArgument TokenInternal.SIN $2 parseState
                                             Sin(arg, Int(1)) 
                                           }
    | sinPrefix CARET arguments arguments  { 
                                             let arg1 = checkForArgument TokenInternal.SIN $3 parseState
                                             let arg2 = checkForArgument TokenInternal.SIN $4 parseState
                                             Sin(arg1, arg2)
                                           }
    | sinPrefix arguments arguments        { 
                                             report parseState "CARET symbol for SIN missing"
                                             let arg1 = checkForArgument TokenInternal.SIN $2 parseState
                                             let arg2 = checkForArgument TokenInternal.SIN $3 parseState
                                             Sin(arg1, arg2)
                                           }
    | cosPrefix arguments                  { 
                                             let arg = checkForArgument TokenInternal.COS $2 parseState
                                             Cos(arg, Int(1))
                                           }
    | cosPrefix CARET arguments arguments  { 
                                             report parseState "CARET symbol for COS missing"
                                             let arg1 = checkForArgument TokenInternal.COS $3 parseState
                                             let arg2 = checkForArgument TokenInternal.COS $4 parseState
                                             Cos(arg1, arg2)
                                           }

binaryExpression:
    | expression PLUS expression   { 
                                     let p = 1
                                     Plus($1, $3)
                                   }
    | expression SUB expression    { Sub($1, $3)  }
    | expression MUL expression    { Mul($1, $3)  }
    | expression TIMES expression  { Mul($1, $3)  }
    | expression DIV expression    { Div($1, $3)  }
    | expression BMOD expression   { Bmod($1, $3) }
	| SUB expression %prec uMinus  { Neg($2) }
	//
	| binaryOperator expression %prec errorRule   { 
                                       report parseState "First operand" 
                                       Plus($2, $2)
                                   }
    | expression binaryOperator %prec errorRule   { 
                                       report parseState "Second operand" 
                                       Plus($1, $1)
                                   }
    | expression recover expression %prec expressionOverAll   { 
                            //let lexeme, sPos, ePos, exVal = $3
                            //let errorMsg = "MAYBE missing binary operator????"
                            //let error = Error(errorMsg, {Line = sPos; Column = ePos})
                            //errorLogger.ReportError(error)
                            report parseState "MAYBE missing binary operator????"
                            Plus($1, $3)
                         }
    | expression expr   %prec errorRule { 
                            let lexeme, sPos, ePos, exVal = $2
                            let errorMsg = "MAYBE missing binary operator?"
                            let error = Error(errorMsg, {Line = sPos; Column = ePos})
                            errorLogger.ReportError(error)
                            
                            Plus($1, exVal)
                         }

binaryOperator:
    | PLUS %prec errorRule {}
    | SUB  %prec errorRule {}
    | MUL  %prec errorRule {}
    | DIV  %prec errorRule {}
    | BMOD %prec errorRule {}

arguments:
    | parens argumentSet parens %prec funcPriority  { 
                                  checkBalancedParen $1 $3 ParenToken.LCURLY ParenToken.RCURLY parseState
                                  Some($2) 
                                }
    | parens parens             {
                                  checkBalancedParen $1 $2 ParenToken.LCURLY ParenToken.RCURLY parseState
                                  None 
                                }

argumentSet:
    | expression %prec argSetPriority     { [$1] }
	| argumentSet COMMA expression %prec argSetPriority { $3::$1 }
	//
	| argumentSet error expression %prec errorRule {
                                       let lexbuf = parseState.ParserLocalStore.["LexBuffer"] :?> LexBuffer<char>
                                       let errorMsg = sprintf "Unexpected symbol: %s. Comma symbol required" (new String(lexbuf.Lexeme))
                                       let error = Error(errorMsg, {Line = lexbuf.StartPos.Line; Column = lexbuf.StartPos.Column})
                                       errorLogger.ReportError(error)
                                       
                                       $3::$1
                                   }
    | argumentSet expr %prec errorRule {
                                       let lexeme, sPos, ePos, exVal = $2
                                       let errorMsg = "Expected comma symbol"
                                       let error = Error(errorMsg, {Line = sPos; Column = ePos})
                                       errorLogger.ReportError(error)
                                       
                                       exVal::$1
                                   }

expr:
    | expression %prec errorRule {
                     let lexbuf = parseState.ParserLocalStore.["LexBuffer"] :?> LexBuffer<char>
                     let posis = parseState.GetInput(1)
                     let posix = parseState.InputStartPosition(1)
                     (new string(lexbuf.Lexeme), posix.Line, posix.Column, $1) 
                 }

recover: 
    //| error %prec recoverRule { 
    | error %prec recoverRule { 
                 let lexbuf = parseState.ParserLocalStore.["LexBuffer"] :?> LexBuffer<char>
                 (new string(lexbuf.Lexeme), lexbuf.StartPos.Line, lexbuf.StartPos.Column) 
             }

parens:
    | LPAREN  { ParenToken.LPAREN }
    | RPAREN  { ParenToken.RPAREN }
    | LCURLY  { ParenToken.LCURLY }
    | RCURLY  { ParenToken.RCURLY }

errorRule:
    | SLASH ID arguments %prec loose_closing_paren      {
                                                          report parseState (sprintf "Undefined function %s" $2)
                                                          Int(1)
                                                        }
    | SLASH ID %prec loose_closing_paren      {
                                                report parseState (sprintf "Undefined function %s" $2)
                                                Int(1)
                                              }
    | SLASH recover arguments %prec loose_closing_paren {
                                                let lexeme, sPos, ePos = $2
                                                report parseState (sprintf "Undefined function %s" lexeme)
                                                Int(1)
                                              }
    | SLASH recover %prec loose_closing_paren {
                                                let lexeme, sPos, ePos = $2
                                                report parseState (sprintf "Undefined function %s" lexeme)
                                                Int(1)
                                              }
    | arguments  %prec loose_closing_paren  {
                                              report parseState "LCURLY RCURLY expression"
                                              match $1 with | Some(x) -> x.Head | None -> Int(1)
                                            }
    | expression parens %prec loose_closing_paren {
                         report parseState (sprintf "Unmatched right %s" ($2.ToString()))
                         $1
                       }
	| parens expression %prec loose_closing_paren {
                                                    report parseState (sprintf "Unmatched left %s" ($1.ToString()))
                                                    $2
                                                  }
