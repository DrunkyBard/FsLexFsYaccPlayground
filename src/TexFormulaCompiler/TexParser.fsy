%{
open TexAst
open System
open Microsoft.FSharp.Text.Lexing
open Microsoft.FSharp.Text.Parsing
open ErrorHandling

let mutable domainSpecificAnalyzer = Unchecked.defaultof<DomainSpecificContext -> obj>
let mutable errorLogger = Unchecked.defaultof<ErrorLogger>

let analyzeDomainSpecificLanguage token = domainSpecificAnalyzer token

let analyzeDomainSpecificSource token startPos = 
    try
      analyzeDomainSpecificLanguage token
    with
      | DomainSpecificParseException(fString, pos) -> failwithf "%s at pos: %u" fString (startPos)

let analyzeDomainSpecificSingleSource src pos = 
    analyzeDomainSpecificSource (SRefValueSrc(src)) pos |> SRefValue

let analyzeDomainSpecificSources sources = 
    let rec analyzeDomainSpecificSourcesInternal sources state = 
        match sources with
          | [] -> state
          | (src, pos)::t -> analyzeDomainSpecificSourcesInternal t ((analyzeDomainSpecificSource (MRefValueSrc(src)) pos)::state)
        
    analyzeDomainSpecificSourcesInternal sources [] 
    |> List.rev 
    |> MRefValue

let report (parseState : IParseState) sym = 
    let lexbuf = parseState.ParserLocalStore.["LexBuffer"] :?> LexBuffer<char>
    let errorMsg = sprintf "Unexpected symbol: %s. %s symbol required" (new String(lexbuf.Lexeme)) sym
    let error = Error(errorMsg, {Line = lexbuf.StartPos.Line; Column = lexbuf.StartPos.Column})
    errorLogger.ReportError(error)

%}

%token <int> INT
%token <float> FLOAT
%token <string> DIFF
%token <string> ID
%token <string*int> SREFVAL
%token <(string*int) list> MREFVAL
%token LPAREN RPAREN LCURLY RCURLY EXCL CARET EQ UNDERSCORE SLASH COMMA
%token PLUS SUB MUL DIV 
%token FRAC SQRT SUM PROD INTEGRAL TIMES INFTY TO LIM BMOD TEXT SIN COS
%token PI EULERNUM
%token EOF

//%nonassoc lparen_error
%nonassoc errorRule
//%nonassoc rparen_error
%left RCURLY INT COMMA
%left PLUS SUB 
%left DIV MUL BMOD
%left missing
%nonassoc high
%right rcur

%start start
%type <TexAst.Expr> start


%%

start:
	| expression EOF { $1 }
	//| ID expression EOF { 
    //                        report parseState ($1)
    //                        $2 
    //                    }

expression:
    | binaryExpression      { $1 }
	| highPriorityFunction  { $1 }
    //| errRule                    { $1 }
   // | expression RCURLY %prec rparen_error                 {
   //                                             report parseState "Unexpected RCURLY"
   //                                             $1
   //                                         }

constant:
	| PI       { Constant(Pi) }
	| EULERNUM { Constant(E) }

sum:
    | SLASH SUM lCurly argumentSet RCURLY      { Sum(List.rev $4) }

prod:
    | SLASH PROD lCurly argumentSet rCurly     { Prod(List.rev $4) }

fact:
    highPriorityFunction EXCL  { Fact($1) }

frac:
    SLASH FRAC lCurly expression rCurly lCurly expression rCurly   { Div($4, $7) }

power:
    | LCURLY expression rCurly CARET lCurly expression rCurly %prec lPrec { 
                                                                             let a = 1
                                                                             Pow($2, $6) 
                                                                          }
    | rCurly CARET lCurly expression rCurly  { 
                                                 report parseState "Right curly unmatched"
                                                 Pow(Int(1), $4) 
                                             }

integral:
    | SLASH INTEGRAL UNDERSCORE lCurly expression rCurly CARET lCurly expression rCurly lCurly expression rCurly DIFF 
                                                                                                    { Integral($12, $14, $5, $9) }
																									
    | SLASH INTEGRAL UNDERSCORE lCurly expression rCurly CARET lCurly expression rCurly lCurly expression DIFF rCurly  
                                                                                                    { Integral($12, $13, $5, $9) }

limit:
    SLASH LIM UNDERSCORE lCurly ID TO expression rCurly lCurly expression rCurly  { Lim($10, $5, $7) }

refPattern:
    | refValue                           { $1 }
	| SLASH TEXT lCurly refValue rCurly  { $4 }



refValue:
    | SREFVAL      { analyzeDomainSpecificSingleSource (fst $1) (snd $1) |> DsAst }
	| MREFVAL      { analyzeDomainSpecificSources $1 |> DsAst }

highPriorityFunction:    
    | INT                        { Int($1) }
    | FLOAT                      { Float($1) }
    | SLASH INFTY                { Float(Double.PositiveInfinity) }
    | LPAREN expression rParen   { $2 }
	| trigonometry               { $1 }
	| sum                        { $1 }
	| prod                       { $1 }
	| fact                       { $1 }
	| integral                   { $1 }
	| constant                   { $1 }
    | power                      { $1 }
    | frac                       { $1 }
	| limit                      { $1 }
	| refPattern                 { $1 }
	| ID                         { Var($1) }
    | errRule     { $1 }
	//| expression RCURLY {
    //                        report parseState "Unexpected RCURLY"
    //                        $1
    //                    }

	
trigonometry: 
    | SLASH SIN lCurly expression rCurly                                 { Sin($4, Int(1)) }
    | SLASH SIN CARET lCurly expression rCurly lCurly expression rCurly  { Sin($8, $5) }
    | SLASH COS lCurly expression rCurly                                { Cos($4, Int(1)) }
    | SLASH COS CARET lCurly expression rCurly lCurly expression rCurly  { Cos($8, $5) }

binaryExpression:
    | expression PLUS expression %prec PLUS  { 
                                     let p = 1
                                     Plus($1, $3)
                                   }
    | expression SUB expression    { Sub($1, $3)  }
    | expression MUL expression    { Mul($1, $3)  }
    | expression DIV expression    { Div($1, $3)  }
    | expression BMOD expression   { Bmod($1, $3) }
	//
	//| expression missingBinary expression %prec missing  { 
    //                                           let lexbuf = parseState.ParserLocalStore.["LexBuffer"] :?> LexBuffer<char>
    //                                           let wrongLexeme, sPos, ePos = $2
    //                                           let errorMsg = sprintf "Unexpected symbol: %s. Required binary operator" wrongLexeme
    //                                           let error = Error(errorMsg, {Line = sPos; Column = ePos})
    //                                           errorLogger.ReportError(error)
	//
    //                                           Plus($1, $3) 
    //                                       }
    
	//| binaryOperator expression    { 
    //                                   report parseState "First operand" 
    //                                   Plus(Int(0), $2)
    //                               }
    //| expression binaryOperator    { 
    //                                   report parseState "Second operand" 
    //                                   Plus($1, $1)
    //                               }

binaryOperator:
    | PLUS {}
    | SUB  {}
    | MUL  {}
    | DIV  {}
    | BMOD {}

argumentSet:
    | expression %prec RCURLY  { [$1] }
	| argumentSet COMMA expression { $3::$1 }
	//
	//| argumentSet error expression {
    //                                   let lexbuf = parseState.ParserLocalStore.["LexBuffer"] :?> LexBuffer<char>
    //                                   let errorMsg = sprintf "Unexpected symbol: %s. Comma symbol required" (lexbuf.Lexeme.ToString())
    //                                   let error = Error(errorMsg, {Line = lexbuf.StartPos.Line; Column = lexbuf.StartPos.Column})
    //                                   errorLogger.ReportError(error)
    //                                   
    //                                   $3::$1
    //                               }

missingBinary: 
    | error  { 
                 let lexbuf = parseState.ParserLocalStore.["LexBuffer"] :?> LexBuffer<char>
                 (new string(lexbuf.Lexeme), lexbuf.StartPos.Line, lexbuf.StartPos.Column) 
             }

lCurly:
    | LCURLY  { LCURLY }
	| error   { 
                  report parseState "Left curly brace" 
                  LCURLY 
              }
 
rCurly:
    | RCURLY  { RCURLY }
	| error   { 
                  report parseState "Right curly brace" 
                  RCURLY 
              }

lParen:
    | LPAREN  { LPAREN }
    | error   { 
                  report parseState "Left paren" 
                  LPAREN 
              }

//slash:
//    | SLASH   { SLASH }
//    | error   { 
//                  report parseState "Left paren" 
//                  SLASH 
//              }

rParen:
    | RPAREN  { RPAREN }
    | error   { 
                  report parseState "Right paren" 
                  RPAREN 
              }

errRule:
   // | expression RCURLY %prec rparen_error {
    | expression RCURLY %prec rparen_error {
                            report parseState "Unexpected RCURLY"
                            $1
                        }