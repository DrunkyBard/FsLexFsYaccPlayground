%{
open TexAst
open System
open Microsoft.FSharp.Text.Lexing
open Microsoft.FSharp.Text.Parsing
open ErrorHandling

let mutable domainSpecificAnalyzer = Unchecked.defaultof<DomainSpecificContext -> obj>
let mutable errorLogger = Unchecked.defaultof<ErrorLogger>

let analyzeDomainSpecificLanguage token = domainSpecificAnalyzer token

let analyzeDomainSpecificSource token startPos = 
    try
      analyzeDomainSpecificLanguage token
    with
      | DomainSpecificParseException(fString, pos) -> failwithf "%s at pos: %u" fString (startPos)

let analyzeDomainSpecificSingleSource src pos = 
    analyzeDomainSpecificSource (SRefValueSrc(src)) pos |> SRefValue

let isSome = function
    | Some(_) -> true
    | None -> false

let analyzeDomainSpecificSources sources = 
    let rec analyzeDomainSpecificSourcesInternal sources state = 
        match sources with
          | [] -> state
          | (src, pos)::t -> analyzeDomainSpecificSourcesInternal t ((analyzeDomainSpecificSource (MRefValueSrc(src)) pos)::state)
        
    analyzeDomainSpecificSourcesInternal sources [] 
    |> List.rev 
    |> MRefValue

let report (parseState : IParseState) sym = 
    let lexbuf = parseState.ParserLocalStore.["LexBuffer"] :?> LexBuffer<char>
    let errorMsg = sprintf "Unexpected symbol: %s. %s symbol required" (new String(lexbuf.Lexeme)) sym
    let error = Error(errorMsg, {Line = lexbuf.StartPos.Line; Column = lexbuf.StartPos.Column})
    errorLogger.ReportError(error)

%}

%token <int> INT
%token <float> FLOAT
%token <string> DIFF
%token <string> ID
%token <string*int> SREFVAL
%token <(string*int) list> MREFVAL
%token LPAREN RPAREN LCURLY RCURLY EXCL CARET EQ UNDERSCORE SLASH COMMA
%token PLUS SUB MUL DIV 
%token FRAC SQRT SUM PROD INTEGRAL TIMES INFTY TO LIM BMOD TEXT SIN COS
%token PI EULERNUM
%token EOF

%left errorRule
%left errorRule1
%left loose_closing_paren
%left recoverRule
%left missingSymbol
%left LCURLY RCURLY RPAREN COMMA
%left ID
%left argSetPriority
%left PLUS SUB funcPriority
%left DIV MUL BMOD
%right EXCL
%left uMinus
%left unexpectedEnumeration
%left expressionOverAll1
%left expressionOverAll

%start start
%type <TexAst.Expr> start


%%

start:
	| expression EOF { $1 }
	//| ID expression EOF { 
    //                        report parseState ($1)
    //                        $2 
    //                    }

expression:
    | binaryExpression      { $1 }
	| highPriorityFunction %prec funcPriority  { $1 }
    //| errRule                    { $1 }
   // | expression RCURLY %prec rparen_error                 {
   //                                             report parseState "Unexpected RCURLY"
   //                                             $1
   //                                         }

constant:
	| PI       { Constant(Pi) }
	| EULERNUM { Constant(E) }

sum:
    | SLASH SUM lCurly argumentSet rCurly       { Sum(List.rev $4) }
	| SLASH recover lCurly argumentSet rCurly %prec errorRule    { 
                                                                   let wrongLexeme, sPos, ePos = $2
                                                                   let errorMsg = sprintf "Unexpected symbol: %s. Required SUM op" wrongLexeme
                                                                   let error = Error(errorMsg, {Line = sPos; Column = ePos})
                                                                   errorLogger.ReportError(error)
                                                                   Sum(List.rev $4) 
                                                                 }
    | SLASH SUM lCurly rCurly %prec errorRule {
                                   report parseState "SUM should have parameters"
                                   Sum([Int(1)])
                               }
	| error SUM lCurly argumentSet rCurly %prec errorRule    { 
                                                                report parseState "SUM operation should starts with SLASH"
                                                                Sum(List.rev $4)
                                                             }
    | expression LCURLY argumentSet rCurly %prec expressionOverAll {
                                             let pos = parseState.InputStartPosition(2)
                                             let posis = parseState.GetInput(2)
                                             let posis1 = parseState.GetInput(1)
                                             let posis2 = parseState.InputStartPosition(1)
                                             let posis3 = parseState.InputEndPosition(1)
                                             let errorMsg = "Unexpected left curly brace expression"
                                             let error = Error(errorMsg, {Line = pos.Line; Column = pos.Column})
                                             errorLogger.ReportError(error)
                                             Sum(List.rev $3)
                                         }

    //| SLASH recover  %prec errorRule {
    //                    let wrongLexeme, sPos, ePos = $2
    //                    let errorMsg = sprintf "Unexpected symbol: %s. Required SUM1 op" wrongLexeme
    //                    let error = Error(errorMsg, {Line = sPos; Column = ePos})
    //                    errorLogger.ReportError(error)
    //                    Sum([Int(1)]) 
    //                  }
    

noname:
    | error    { report parseState "unexpected NAME"}

prod:
    | SLASH PROD lCurly argumentSet rCurly     { Prod(List.rev $4) }

fact:
    highPriorityFunction EXCL  { Fact($1) }

frac:
    SLASH FRAC lCurly expression rCurly lCurly expression rCurly   { Div($4, $7) }

power:
    | LCURLY expression rCurly CARET lCurly expression rCurly    %prec expressionOverAll         { 
                                                                             let a = 1
                                                                             Pow($2, $6) 
                                                                          }
    | LCURLY expression rCurly lCurly expression rCurly    %prec expressionOverAll         { 
                                                                             report parseState "MISSING CARET111"
                                                                             Pow($2, $5) 
                                                                          }
    //| LCURLY expression rCurly recover LCURLY expression RCURLY    %prec expressionOverAll         { 
    //                                                                         report parseState "MISSING CARET111"
    //                                                                         Pow($2, $6) 
    //                                                                      }
    | expression CARET lCurly expression rCurly  { 
                                                 report parseState "Right curly unmatched"
                                                 Pow(Int(1), $4) 
                                             }
    

integral:
    | SLASH INTEGRAL UNDERSCORE lCurly expression rCurly CARET lCurly expression rCurly lCurly expression rCurly DIFF 
                                                                                                    { Integral($12, $14, $5, $9) }
																									
    | SLASH INTEGRAL UNDERSCORE lCurly expression rCurly CARET lCurly expression rCurly lCurly expression DIFF rCurly  
                                                                                                    { Integral($12, $13, $5, $9) }

limit:
    SLASH LIM UNDERSCORE lCurly ID TO expression rCurly lCurly expression rCurly  { Lim($10, $5, $7) }

refPattern:
    | refValue                           { $1 }
	| SLASH TEXT lCurly refValue rCurly  { $4 }



refValue:
    | SREFVAL      { analyzeDomainSpecificSingleSource (fst $1) (snd $1) |> DsAst }
	| MREFVAL      { analyzeDomainSpecificSources $1 |> DsAst }

highPriorityFunction:    
    | INT                        { Int($1) }
    | FLOAT                      { Float($1) }
    | SLASH INFTY                { Float(Double.PositiveInfinity) }
    | LPAREN expression RPAREN   { $2 }
	| trigonometry               { $1 }
	| sum                        { $1 }
	| prod                       { $1 }
	| fact                       { $1 }
	| integral                   { $1 }
	| constant                   { $1 }
    | power                      { $1 }
    | frac                       { $1 }
	| limit                      { $1 }
	| refPattern                 { $1 }
	| ID                         { Var($1) }
    | errRule     { $1 }
	//| expression RCURLY {
    //                        report parseState "Unexpected RCURLY"
    //                        $1
    //                    }

	
trigonometry: 
    | SLASH SIN lCurly expression rCurly                                 { Sin($4, Int(1)) }
    | SLASH SIN caret lCurly expression rCurly lCurly expression rCurly  { Sin($8, $5) }
    | SLASH COS lCurly expression rCurly                                 { Cos($4, Int(1)) }
    | SLASH COS caret lCurly expression rCurly lCurly expression rCurly  { Cos($8, $5) }
	| error trigName lCurly expression rCurly %prec errorRule    { 
                                                                     report parseState "SIN/COS operation should starts with SLASH"
                                                                     Sin($4, Int(1))
                                                                  }

trigName: 
    | SIN {}
	| COS {}

binaryExpression:
    | expression PLUS expression   { 
                                     let p = 1
                                     Plus($1, $3)
                                   }
    | expression SUB expression    { Sub($1, $3)  }
    | expression MUL expression    { Mul($1, $3)  }
    | expression DIV expression    { Div($1, $3)  }
    | expression BMOD expression   { Bmod($1, $3) }
	| SUB expression %prec uMinus  { Neg($2) }
	//
	//| expression error %prec errorRule { 
    //                                           let lexbuf = parseState.ParserLocalStore.["LexBuffer"] :?> LexBuffer<char>
    //                                           let wrongLexeme, sPos, ePos = $2
    //                                           let errorMsg = sprintf "Unexpected symbol: %s. Required binary operator" wrongLexeme
    //                                           let error = Error(errorMsg, {Line = sPos; Column = ePos})
    //                                           errorLogger.ReportError(error)
    //                                           
    //                                           Plus($1, Int($3)) 
    //                                       }
    
	| binaryOperator expression %prec errorRule   { 
                                       report parseState "First operand" 
                                       Plus($2, $2)
                                   }
    | expression binaryOperator %prec errorRule   { 
                                       report parseState "Second operand" 
                                       Plus($1, $1)
                                   }
    | expression expr   %prec expressionOverAll { 
                            let lexeme, sPos, ePos, exVal = $2
                            let errorMsg = "MAYBE missing binary operator?"
                            let error = Error(errorMsg, {Line = sPos; Column = ePos})
                            errorLogger.ReportError(error)
                            
                            Plus($1, exVal)
                         }
    | expression sym expr   %prec expressionOverAll { 
                            let lexeme, sPos, ePos, exVal = $3
                            let errorMsg = "MAYBE missing binary operator????"
                            let error = Error(errorMsg, {Line = sPos; Column = ePos})
                            errorLogger.ReportError(error)
                            
                            Plus($1, exVal)
                         }

sym:
   | COMMA {}
   | CARET {}


binaryOperator:
    | PLUS %prec errorRule {}
    | SUB  %prec errorRule {}
    | MUL  %prec errorRule {}
    | DIV  %prec errorRule {}
    | BMOD %prec errorRule {}

argumentSet:
    | expression %prec argSetPriority  { 
                                           let a = 1
                                           //report parseState "argPassed"
                                           [$1]
                                          }
	| argumentSet COMMA expression { 
                                     //report parseState "argPassed"
                                     $3::$1 
                                   }
	//
    //| expression expr %prec expressionOverAll {
    //                       let lexeme, sPos, ePos, exVal = $2
    //                       let errorMsg = sprintf "Unexpected symbol: %s. Comma444 symbol required" lexeme
    //                       let error = Error(errorMsg, {Line = sPos; Column = ePos})
    //                       errorLogger.ReportError(error)
	//
    //                       exVal::$1::[]
    //                   }
    //| argumentSet expr %prec expressionOverAll {
    //                       let lexeme, sPos, ePos, exVal = $2
    //                       let errorMsg = sprintf "Unexpected symbol: %s. Comma5 symbol required" lexeme
    //                       let error = Error(errorMsg, {Line = sPos; Column = ePos})
    //                       errorLogger.ReportError(error)
	//
    //                       exVal::$1
    //                   }
	//| expr expression %prec MUL {
    //                             report parseState "Comma111"
    //                             $1
    //                         }
	| argumentSet error expression %prec expressionOverAll1 {
                                       let lexbuf = parseState.ParserLocalStore.["LexBuffer"] :?> LexBuffer<char>
                                       let errorMsg = sprintf "Unexpected symbol: %s. Comma symbol required" (new String(lexbuf.Lexeme))
                                       let error = Error(errorMsg, {Line = lexbuf.StartPos.Line; Column = lexbuf.StartPos.Column})
                                       errorLogger.ReportError(error)
                                       
                                       $3::$1
                                   }
    | argumentSet expr %prec expressionOverAll1 {
                                       let lexeme, sPos, ePos, exVal = $2
                                       let errorMsg = "Expected comma symbol"
                                       let error = Error(errorMsg, {Line = sPos; Column = ePos})
                                       errorLogger.ReportError(error)
                                       
                                       exVal::$1
                                   }

expr:
    | expression %prec expressionOverAll1 {
                     let lexbuf = parseState.ParserLocalStore.["LexBuffer"] :?> LexBuffer<char>
                     let posis = parseState.GetInput(1)
                     let posix = parseState.InputStartPosition(1)
                     (new string(lexbuf.Lexeme), posix.Line, posix.Column, $1) 
                 }

recover: 
    | error %prec recoverRule { 
                 let lexbuf = parseState.ParserLocalStore.["LexBuffer"] :?> LexBuffer<char>
                 (new string(lexbuf.Lexeme), lexbuf.StartPos.Line, lexbuf.StartPos.Column) 
             }

//symbol:
//    | CARET  { Some(CARET) }
//	| LCURLY { Some(LCURLY) }
//	| RCURLY { Some(RCURLY) }
//	| LPAREN { Some(LPAREN) }
//	| RPAREN { Some(RPAREN) }
//	| error %prec missingSymbol { None }

lCurly:
    | LCURLY    { LCURLY }
	| recover   { 
                  report parseState "Left curly brace" 
                  LCURLY 
                }
 
rCurly:
    | RCURLY  { Some(RCURLY) }
	| recover %prec errorRule  { 
                                   report parseState "Right curly brace" 
                                   None
                               }

lParen:
    | LPAREN  { LPAREN }
    | recover   { 
                  report parseState "Left paren" 
                  LPAREN 
                }

rParen:
    | RPAREN  { RPAREN }
    | recover   { 
                  report parseState "Right paren" 
                  RPAREN 
                }

caret:
    | CARET { CARET }
    | recover {
                  report parseState "MISSING CARET"
                  CARET
              }

errRule:
   // | expression RCURLY %prec rparen_error {
    | LCURLY expression rCurly %prec loose_closing_paren {
                                                           report parseState "LCURLY RCURLY expression"
                                                           $2
                                                         }
    | expression rCurly %prec loose_closing_paren {
                            if isSome $2 then report parseState "Unexpected RCURLY"
                            //match $2 with
                            //    | Some(RCURLY) -> report parseState "Unexpected RCURLY"
                            //    | _ -> report parseState "Unexpected SYMBOLLLL"
                            
                            $1
                        }
    //| expression RPAREN %prec loose_closing_paren {
    //                        report parseState "Unexpected RPAREN"
    //                        $1
    //                     }
    | LPAREN expression %prec loose_closing_paren  {
                             report parseState "LPAREN WITHOUT RPAREN"
                             $2
                         }
    | LCURLY expression %prec loose_closing_paren  {
                             report parseState "LCURLY WITHOUT RCURLY"
                             $2
                         }

//    | argumentSet %prec loose_closing_paren {
//                                              
//                                            
//                                            
//                                            }


