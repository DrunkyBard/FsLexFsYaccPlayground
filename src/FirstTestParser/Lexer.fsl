{
module SqlLexer
open SqlParser
open System
open Microsoft.FSharp.Text.Lexing

let lexeme = LexBuffer<_>.LexemeString

let keywords =   
    [   
        "SELECT", SELECT;
        "FROM", FROM;
        "WHERE", WHERE;   
        "ORDER", ORDER;   
        "BY", BY;   
        "JOIN", JOIN;   
        "INNER", INNER;   
        "LEFT", LEFT;   
        "RIGHT", RIGHT;   
        "ASC", ASC;   
        "DESC", DESC;   
        "AND", AND;   
        "OR", OR;   
        "ON", ON;
        "AS", AS;
        "TRUE", BOOL(true);
        "FALSE", BOOL(false);
    ] |> Map.ofList   
 
let ops =   
    [   
        "=",    EQ;   
        "<",    LT;   
        "<=",   LE;   
        ">",    GT;   
        ">=",   GE;   
        "<>",   NEQ;
    ] |> Map.ofList  
}

let whitespace = ' ' | '\t'
let newLine = "\r\n" | "\r" | "\n"
let char = ['a'-'z' 'A'-'Z'] 
let digit = ['0'-'9']      
let identifier  = char(char|digit|['-' '_'])*
let comma = ","
let dot = "."
let ops = "<" | "<=" | ">" | ">=" | "=" | "<>"
let int = ['-' '+']? digit+

rule lex = 
  parse
  | whitespace  { lex lexbuf }
  | newLine     { lexbuf.StartPos <- lexbuf.StartPos.NextLine; lex lexbuf }
  | int         { INT (int (lexeme lexbuf)) }
  | identifier  { 
                    match Map.tryFind ((lexeme lexbuf).ToUpper()) keywords with
                             | Some(kw) -> kw
                             | None     -> ID(lexeme lexbuf) 
                }
  | ops         { ops.[lexeme lexbuf] }
  | comma       { COMMA }
  | dot         { DOT }
  | eof         { EOF }
  | _           {  failwith ("ParseError: " + lexeme lexbuf) }

